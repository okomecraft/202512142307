<!DOCTYPE html>
<html lang="ja">
<head>
    <meta charset="UTF-8">
    <title>3D Viewer - Smart Turn Navigation</title>
    <style>
        body { margin: 0; overflow: hidden; background-color: #f0f0f0; }
        canvas { display: block; width: 100vw; height: 100vh; }
        #debug-log {
            position: absolute; top: 10px; left: 10px;
            background: rgba(0,0,0,0.7); color: white;
            padding: 8px 12px; font-family: monospace; font-size: 12px;
            pointer-events: none; z-index: 1000; border-radius: 4px;
        }
        .controls {
            position: absolute; bottom: 30px; left: 50%;
            transform: translateX(-50%); display: flex; gap: 15px; z-index: 2000;
        }
        .btn {
            padding: 15px 30px; font-size: 16px; font-weight: bold; cursor: pointer;
            color: white; border: none; border-radius: 30px;
            box-shadow: 0 4px 15px rgba(0, 0, 0, 0.2);
            transition: all 0.2s; background: #7f8c8d;
        }
    </style>
</head>
<body>
    <div id="debug-log">Status: Click ground!</div>
    <div class="controls" id="ui-panel"></div>

    <script type="importmap">
        {
            "imports": {
                "three": "https://unpkg.com/three@0.166.1/build/three.module.js",
                "three/addons/": "https://unpkg.com/three@0.166.1/examples/jsm/"
            }
        }
    </script>
    
    <script type="module">
        import * as THREE from 'three';
        import { OrbitControls } from 'three/addons/controls/OrbitControls.js';
        import { GLTFLoader } from 'three/addons/loaders/GLTFLoader.js';

        const logElement = document.getElementById('debug-log');
        const uiPanel = document.getElementById('ui-panel');
        function debugLog(msg) { logElement.innerText = "Status: " + msg; }

        const scene = new THREE.Scene();
        const camera = new THREE.PerspectiveCamera(45, window.innerWidth / window.innerHeight, 0.1, 1000);
        camera.position.set(0, 5, 10);

        const renderer = new THREE.WebGLRenderer({ antialias: true, alpha: true });
        renderer.setSize(window.innerWidth, window.innerHeight);
        renderer.setPixelRatio(window.devicePixelRatio);
        document.body.appendChild(renderer.domElement);

        scene.add(new THREE.AmbientLight(0xffffff, 2.0));
        const dirLight = new THREE.DirectionalLight(0xffffff, 1.5);
        dirLight.position.set(5, 10, 7);
        scene.add(dirLight);

        const ground = new THREE.Mesh(new THREE.PlaneGeometry(100, 100), new THREE.MeshBasicMaterial({ visible: false }));
        ground.rotation.x = -Math.PI / 2;
        scene.add(ground);

        let mixer, model, blobShadow;
        let actions = {}; 
        let activeAction = null; 
        let targetPosition = null;
        let isMoving = false;
        let isProcessing = false;

        const controls = new OrbitControls(camera, renderer.domElement);
        controls.enableDamping = true;

        new GLTFLoader().load('./model.glb', (gltf) => {
            model = gltf.scene;
            scene.add(model);
            mixer = new THREE.AnimationMixer(model);
            gltf.animations.forEach((clip, index) => {
                const action = mixer.clipAction(clip);
                actions[clip.name || `Motion ${index}`] = action;
                const btn = document.createElement('button');
                btn.className = 'btn';
                btn.innerText = clip.name || `Motion ${index}`;
                btn.onclick = (e) => { e.stopPropagation(); switchAction(clip.name); };
                uiPanel.appendChild(btn);
            });
        });

        window.addEventListener('mousedown', (event) => {
            if (!model || isProcessing || isMoving) return;
            const mouse = new THREE.Vector2(
                (event.clientX / window.innerWidth) * 2 - 1,
                -(event.clientY / window.innerHeight) * 2 + 1
            );
            const raycaster = new THREE.Raycaster();
            raycaster.setFromCamera(mouse, camera);
            const intersects = raycaster.intersectObject(ground);
            if (intersects.length > 0) {
                targetPosition = intersects[0].point;
                processNavigation();
            }
        });

        async function processNavigation() {
            isProcessing = true;
            debugLog("Turn Sequence Start...");

            const jumpAction = actions['垂直ジャンプ'] || Object.values(actions)[1];
            const runAction = actions['走行'] || Object.values(actions)[0];

            // 1. 向きが合うまでジャンプを繰り返す
            while (true) {
                const toTarget = new THREE.Vector3().subVectors(targetPosition, model.position);
                toTarget.y = 0;
                const targetAngle = Math.atan2(toTarget.x, toTarget.z);
                let diffAngle = targetAngle - model.rotation.y;

                // -PI to PI の範囲に正規化
                while (diffAngle > Math.PI) diffAngle -= Math.PI * 2;
                while (diffAngle < -Math.PI) diffAngle += Math.PI * 2;

                // 許容範囲（5度以内）なら終了
                if (Math.abs(diffAngle) < THREE.MathUtils.degToRad(5)) break;

                // 今回のジャンプで回転する量を決める（最大60度）
                const maxTurn = THREE.MathUtils.degToRad(60);
                const stepTurn = Math.sign(diffAngle) * Math.min(Math.abs(diffAngle), maxTurn);

                // ジャンプ開始
                await fadeTo(jumpAction, 0.1);
                
                // ジャンプの滞空時間に合わせて回転（ここでは0.8秒で回転させる例）
                const startRotation = model.rotation.y;
                const startTime = performance.now();
                const turnDuration = 800; 

                await new Promise(resolve => {
                    function rotate() {
                        const elapsed = performance.now() - startTime;
                        const progress = Math.min(elapsed / turnDuration, 1);
                        model.rotation.y = startRotation + stepTurn * progress;
                        if (progress < 1) requestAnimationFrame(rotate);
                        else resolve();
                    }
                    rotate();
                });

                await new Promise(r => setTimeout(r, 100)); // 着地の間
            }

            // 2. 走行へ移行
            debugLog("Moving...");
            await fadeTo(runAction, 0.3);
            isMoving = true;
            isProcessing = false;
        }

        async function fadeTo(nextAction, duration) {
            if (!nextAction || activeAction === nextAction) return;
            if (activeAction) activeAction.fadeOut(duration);
            nextAction.reset().setEffectiveWeight(1).fadeIn(duration).play();
            activeAction = nextAction;
        }

        function animate() {
            requestAnimationFrame(animate);
            if (mixer) mixer.update(1/60);

            if (isMoving && model && targetPosition) {
                const dist = model.position.distanceTo(new THREE.Vector3(targetPosition.x, model.position.y, targetPosition.z));
                if (dist > 0.1) {
                    const dir = new THREE.Vector3().subVectors(targetPosition, model.position);
                    dir.y = 0;
                    model.position.add(dir.normalize().multiplyScalar(0.06));
                } else {
                    isMoving = false;
                    if (activeAction) activeAction.fadeOut(0.5);
                    activeAction = null;
                    debugLog("Goal!");
                }
            }

            if (model) {
                const shadow = scene.children.find(c => c.geometry?.type === 'PlaneGeometry' && c !== ground);
                if (shadow) shadow.position.set(model.position.x, 0.002, model.position.z);
            }
            controls.update();
            renderer.render(scene, camera);
        }
        animate();
    </script>
</body>
</html>
